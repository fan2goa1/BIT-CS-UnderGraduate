
1 A+B (I)

这道题就是一个二进制的高精度加法，注意一下进位的问题。然后这道题输出答案的时候-的个数是ans的长度+2。对于多组询问，一定注意之前数组的值不要对当前询问产生影响，最好memset初始化一下。

2 解谜游戏

这道题显然可以得知每个点最多被按一次，且按的顺序对最终结果没有任何影响，所以说我们可以$2^m$暴力枚举第一行的操作状态，然后之后对于第i行的亮暗状态(0/1)，我们可以得知第i+1行的操作，使得前i行全暗（0）（例如，第i行第j列是1，那么我们对第i+1行第j列要按一次，使得其变为0），然后最后注意判断第n行是否全0然后更新一下ans。

3 军训日记

1~n中，含质因数2的数的个数最多，然后我们肯定是要让它们分散开来，这样要分$\lfloor \frac{n}{2} \rfloor$个集合（1可以扔到任意一个集合中），然后对于之后的奇合数，由于相邻两数互质，将其扔到比它小1的偶数的集合中即可。注意n=1的时候要特判一下。

4 北湖挖坑

这个好像就是noip2018的某个t1原题，我们把它倒过来，想象成对每个位置建一个高度为b[i] = h-a[i]的山。那么考虑贪心。对于当前第i位，考虑i-1填完后，为了填满i位置，要单独再填多少次。若i-1位置的高度<i位置要建的高度，那么将二者的高度差累加到答案中。这样做法的正确性我们可以考虑如果b[i-1]=b[i]，那么二者可以捆绑看成一个位置，一起被填；若b[i-1]>b[i]那么我们就认为是在达到b[i]高度前二者被捆绑在一起被填，然后当到了高度b[i]，舍弃i位置，i-1位置继续填；若b[i-1]<b[i]，那么我们填到b[i-1]高度时，i位置要单独再花b[i]-b[i-1]次填满。注意开long long

5 北湖深坑

这道题我们考虑对于第i个位置，能装多少水。易知对于当前位置，它能装的最大的高度就是它左边的最高高度和右边的最高高度取min，不然装的更多会从一侧溢出。所以我们O(n)扫一遍得到每个位置左边的最大高度和右边的最大高度。还是注意开long long统计答案

昨天做题的一些心得：

自己对于字符串的很多基本、基础知识还有缺漏，要进行学习。还有就是自己的数论知识尤为欠缺，第八题的扩展欧拉定理都不会...还有就是有时候太粗心，直接交gcc上去了导致ce或者第七题没关freopen而wa，然后罚时暴增，以后多多注意。这周的题总体上还是比较简单，但是要注意一些特殊情况的判断，要对问题考虑全面。



第六题题解

这道题就是要让我们将一个英文文本改成符合英语写作（句首第一个字母大写，剩下小写）规范。

所以我们可以开一个flag(0 / 1)表示刚才是否读到了一个完整句的标点符号（？！.），如果flag=1，那么我们读到的下一个字母就应该大写，并且把flag改回0；如果flag=0，那么我们下一个读到的字母改成小写。特判一下如果读入的字符是（？！.）那么就把flag改成1。模拟一下即可。

对于输入上，读入可以while(gets(s))或者while(scanf("%s", s) != EOF)，表示读到文件结束。



第七题题解

这道题确实最开始不会，无从下手，自己对编码这块真的是了解太少了。本题的关键就是要学会utf-8编码（在这题应该就是指汉字）向unicode的转化，首先一个字占一字节，它首位是0，后七位就是ascii码，形如0xxxxxxx；如果占两字节，就是110xxxxx 10xxxxxx；如果占三字节，就是1110xxxx 10xxxxxx 10xxxxxx；四字节同理。其unicode就是x部分拼接在一起。然后用一个数组记录第i个unsigned char是属于几字节的，用于输出（比如两字节输出就是printf("%c%c", a, b); 三字节就是printf("%c%c%c", a, b, c)）；同时开一个map（STL容器）记录每个unicode编码出现的次数。

扫完一遍后如果所有的unicode的出现次数都==1那么就输出No repeat!；否则从0开始枚举unicode（最大应该到65536），输入答案即可。

对于输入，我是用了getchar一个一个地读。然后还要注意的就是要开unsigned char，char好像只有7位，这样读进来会使得首位的1被当成符号位而得到负数。



第八题题解

这道题我看周围好多人用扩展欧拉定理的，感觉自己的方法好鸡肋。。。

记f[i]表示的后三位，求f数组就可以O(10*m)求出来，利用$10^i=10\times 10^{i-1}$，所以如果知道了f[i-1]，则f[i]=f[i-1]的10次方对1000取模。然后我们用char数组存储每一位，对于从左往右的第i位，它对ans的贡献就是f[n+1-i] * 该位的数值（我的下标是从1开始的）。



第九题题解

这道题最开始属实没有思路，就想到暴力枚举从t串的哪开始拿珠子。如果再暴力枚举取s串的那个位置，O(n*m)的时间复杂度会TLE，所以我们考虑预处理出来f[i, j]表示向后和s串第i位最近的字符j的位置，这个具体实现我们可以倒着扫一遍s串，lst[j]记录字符j最后出现的位置，那么f[i, j] = lst[j]，并更新lst[p] = i，p为第i位的的字符。然后我们暴力枚举开始选取的位置，不停的跳f[i, t[j]]即可，其中i为当前s串的第i位，j为目前要取的t串的位置。然后每次O(m)判断当前枚举的答案和之前得到的答案的字典序大小（并更新）。注意比较字典序要逐位比较，一旦在某一位二者不一样，那么字典序大小便比较出来了。

关于第九题的一些问题

这两天发现第九题周围有一些同学测试点5、6、7过不去，wrong answer。后来发现大部分原因都是字典序比较写错了。有些只判断了当前位>，有些则只判断了当前位<。

举个例子，那上面说的比较时只写了if(f[j] < ans[j]) flag = 1的（其中f数组为当前枚举的起点得到的答案，ans为之前所有枚举得到的字典序最小的，flag = 0/1 表示否/是更新ans），如果ans数组里存的是1 5 6，f数组里存的是2 3 4，那么照上面那种写法就会更新，但这是错误的。所以说我们还要加上一条判断else if(f[j] > ans[j]){flag = 0; break;}这样才完整。



第十题题解

对于单独的一个括号序列，判断其合不合法就是一个压弹栈的过程，即任何时刻都不可能有）多于（且最后二者总数相等。那么根据这个，我们可以把给定的每个括号序列都进行化简，从左往右扫，如果有匹配上的就消掉，比如((())()消完后就是(，因为是模拟压弹栈的过程，所以最后只可能有四种情况：

1. 全剩（
2. 全剩）
3. 空
4. 形如）（的，即开头为），结尾为（，仔细想想就知道这个跟谁匹配都匹不上，所以这种情况就可以舍去了。

那么考虑1-3的三种情况，情况3只能和情况3的匹配，所以开一个变量记录情况3的括号序列的个数cnt，其对ans的贡献则是$\lfloor \frac{cnt}{2}\rfloor$，对于情况1和2，得找剩的括号数一样的才能相互匹配，然后我们可以开两个数组l[i]，r[i]分别表示左括号剩i的括号序列的个数、右括号剩i的括号序列的个数（由于是计数题，那么我们记录东西的时候一定要往记录个数上靠）。对于l[i]，r[i]对答案的贡献就是$min\{l[i],r[i]\}$。



第11题题解


这道题感觉写起来确实细节和讨论的有点多...重点在于研究牌堆的牌，因为它有顺序讲究，手牌则就是一个屯牌的地。

首先对于一种可行的方案，就是n轮过后手中集齐1-n这n张牌，然后再按顺序摆，最多是n*2次。

考虑如何优化这个方案。就是说，我们可以在将一张牌k放入牌堆底的时候，从牌堆顶再回收一张编号为k+1~n的牌，且对于每一次这样的操作，我们需要保证k牌打出去、回收堆顶牌之后，编号为k+1的牌在手中（因为只有这样你才能在下一次打出k+1）。

这时候我们分类讨论一下。

**第一种情况**是牌堆底不存在某一连续段1,2,3...t。对于这种情况，我们必须从1开始一点点放牌直到形成1,2,3,..,n的牌堆。这时我们要考虑一个问题，就是当打出1之后，对于2~n这些牌，能不能连续的被打出来。对于判断这种情况，我们开一个数组need[i]，表示编号为i的牌至少再过多少轮之后能被打出去。显然对于一开始在手牌里面的牌，need[i]=0；一开始在牌堆自顶向下的第i张编号为b[i]的牌有need[b[i]] = i+1。显然当我们开始准备打出1到形成1,2,3,..,n的牌堆需要n轮。那么现在我们要算的就是需要屯多少轮使得之后1~n能被连续的打出来。考虑一下就知道我们要求的是max(need[i] - pos[i])，i取值为t+1,...,n，其中pos[i]表示编号为i的牌一开始在牌堆的位置。这个值+n即是这种情况的答案。

**第二种情况**略微复杂一些。就是牌堆底存在某一连续段1,2,3,...,t。那么考虑潜在的最优解法，即连续的放完t+1,...,n，共花费n-t轮，但这究竟能否做到呢？还是借助上面的need数组，如果要能连着打完这n-t张牌，那么对每个t+1 <= i <= n，有need[i]-pos[i] <= i - t，因为只有这样，我们才能保证每次要打的下一张牌都在我的手牌里，所以满足这个条件的，ans就为n-t； 否则就会出现“断档”，那么一断我们就得重来。如果会有“断档”，我们又得重新从1开始打牌以完成1,2,...,n的牌堆。记录最开始1在牌堆的位置为s（其实s就是n-t+1，为了方便我们拿s表示），那么ans = s-1+1+n，即先过s-1轮，1到牌堆最上面了，且现在手里握有t+1,...,n这些牌，那么接下来一轮我们拿上1放0，之后n轮每一轮就可以按1,2,3,...,n的顺序放了。



第12题题解


对于这样相邻两两交换，首先我们会感觉到，最少的步数大概就是最小的数移到最左边，然后次小数移到第二个位置这样以此类推。这样使得每次交换的两个数都会有左边那个数>右边那个数，所以一定是最小的。

然后这里介绍一下逆序对，对于1 <= i < j <= n，如果有a[i] > a[j]，那么(i, j)就是一个逆序对。因为上面的那种方法每次交换的都是左>右的数，且所有左>右都会被交换一次，所以对于这种方法，其实就是求数列的逆序对个数。

举个例子，假设当前有m个数，交换k次能排好序。那么如果在最后面加一个数p，那么当这m+1个数排好序，比刚才m个数增加的交换次数就是前面m个数中比p大的数与p的交换，即含有p的逆序对个数。

然后接下来我们的目标就是求逆序对，首先逆序对最大可能是n^2级别的，所以我们一定要开long long。对于求逆序对，可以用归并排序，bit。

1.归并排序，归并排序的思想在此不赘述。对于归并的过程，我们在每次归并的时候计算从带合并的两部分各取一个形成的逆序对个数。当判断有a[i]>a[j]时，则对逆序对个数ans的贡献时mid - i + 1，因为i~mid这段都比a[j]大。

2.树状数组。这个其实就比较暴力了，开个桶t[x]表示x出现了多少次，然后O(n)从左往右扫一遍数列，对于a[i]，对ans的贡献是\sum_k=1^{a[i]-1}t[k]。由于数据范围较大，但是每次至多3e5个数，我们可以先对数列离散化再用上述方法。

对于离散化，一个比较简便的写法就是利用STL中的sort、unique和lowber_bound，具体代码实现可百度。



第13题题解

这题上课的时候讲过。

就是按右端点从小到大排序，如果左端点没有被覆盖就可以使ans++，这样局部最优解是全局最优解。



第14题题解

这道题最朴素的做法就是枚举两个看看能不能拼一块然后再枚举一个的情况更新ans，但n^2显然是过不去的。

既然学习了排序，我们想一想排序得到的单调性质能不能简化求解过程呢？

首先就是易知这道题对于两个拼接的情况，贪心的想，就是使较长两边对齐拼接后得到的最短边的最大值；对于一个的情况，就是求三边最小值的最大值。那么我们用struct开x y z分别存最短边 中等边 最长边（方便之后sort比较）。

然后我们sort以y为第一关键字，z为第二关键字，x为第三关键字从小到大排序。这样y、z（较长两边）相等的水晶块就连在了一起，我们O(n)扫一遍开几个变量记一下，具体操作就是如果相邻两个y和z相等，那么将他俩的x相加求min再更新ans即可。然后再O(n)扫一下不拼接的情况，更新ans。



第15题题解

这道题其实我也不太会证，就只能大概感性分析一下（也可能是错的）。

我们先把经验值分成非负和负的两部分。至于为什么这样分，我们考虑对于一个给定顺序的，经验值全部都是非负数的恶龙，我们如果在中间插一个经验值为负的，会使得后面每打一个龙的时候，攻击力都会比原先低一些，使得这样的结果一定不优于原先的结果。所以我们将非负和负分开考虑。

对于非负的，比较显然的是我们可以以难度值从小到大排序打怪。这个也感性证明一下：对于已有的打怪顺序，定下一个应该打什么怪，记已定好顺序的最后一个龙的难度值是x0，如果打的不是当前可选的经验值最小的（记为x1），记其为x2，那么我们要氪x2-x0，而如果先打x1再经过一段打怪过程打到x2，那么氪金值一定<=x2-x0，因为中间有可能有经验值加，故每次打当前难度值最低的。

对于负的，感觉不太好证，这里是我对大佬的想法的理解。我们把它想象成倒着打，即先+(-y)的经验值再打难度值为x的恶龙。这样的话变成了先加经验再打怪，那么对于每一个怪，如果我们打它之前有>=x+y的攻击力，加完-y的经验就不用氪金去打它了，我们还可以把它看成：打一个难度值为x+y的怪，打完后加上-y经验值，那么这就转化成上面那种情况的样子，然后就是x+y从小到大排。但是注意，我们这是倒着的，所以对于正着的顺序，我们得按降序排。



第16题
这道题由于曼哈顿距离是x、y坐标分开的，所以我们可以分开考虑。对于前i个，我们考虑中位数位置为最优方案，然后发现不管往左还是往右移，其距离和>=到中位数的距离之和的。

所以我们现在就要维护前i个数的中位数。具体操作就是假定当前中位数为x，小于x的放进大根堆，大于等于x的放进小根堆。然后每新进来一个数，我们判断当前中位数是否发生了偏移（大根堆个数和小根堆个数之差==2），每次最多偏一个，调整之后将新加的数距新的中位数x'的距离类加进ans即可。



第17题
这道题我们考虑维护一个单调栈。

首先很明确的一点，我们从某一个位置看过去，看到的楼房的高度是严格单调递增的 所以说这意味着我们到第i个位置要维护一个结尾为h[i]的高度严格单调递减的序列。

做法就是每次将栈中height>=h[i]的元素弹出，并开一个flag数组记录在栈中的颜色情况，然后将h[i]加入栈中，统计ans



第18&19题
这两道题还是对栈的一个应用。如果相邻的两个不平的话且相差高度为2的倍数我们肯定先要用1*2给它补平，然后再用2 * 1的将它们和其他的不平，
所以说具体操作起来就是看当前i位置高度和栈顶的高度之差是不是2的倍数，如果是的话弹出栈，不是的话将当前压入栈。如果最后栈中剩0或1个元素则为yes，否则为no。

填坑II只能横着填，这就意味着，我们得在两个相平的基础上往上加高度。
所以我们每次取栈顶元素看和当前的高度一不一样，一样就弹出。但是注意，2 4 4 2 5这种应该是no，所以我们还要判断每次相平的高度，所以栈内应该时刻是单调递减的，如果不是的话就是no。



第20题
这道题我们对每个盒子用top记录盒子最上面的物品的编号，用bottom记录盒子最下面的物品的编号。

将每个编号看成一个点，每一次将盒子x的东西移到盒子y就相当于，把x的top表示的编号的点和y的top表示的标编号的点用一条无向边连接，把y的top设成x的bottom，最后把x的top和bottom清空。

那么进行m此操作后，对于查找每一个盒子里的物品，我们从top表示的编号的点开始往下dfs，注意记录一下father，这样遍历下去，即可得到答案。



第21题
这道题不错，大概就是考查怎么建图。

首先如果我们把一个成语看作一个点的话，边的数目就可能会有很多，因为点数就300000了，这样显然是不行的。

这时我们注意到，成语接龙，是要让前一个的最后一个字=后一个的第一个字，而且每个字用1000000以内的数来表示，故每个字我们可以把它看成是一个点，一个成语就是一条边，每条边连接着成语的第一个字和最后一个字，边权为1。

这样的话我们就只需要求开始成语的最后一个字到结束成语的第一个字的两点之间的最短路，可以直接SPFA，但是由于边权都是1，其实就是今天上课讲的bfs。

注意判断开始成语是否等于结束成语，且这两个成语是否在小张的成语库中。



第22题
这道题感觉比T21难一点，还是一个bfs。

我们bfs是需要将很多个状态扔到queue中，对于这道题，我们的一个状态记录当前所在的点(x, y)，所花费的总时间这些东西，可以写进一个struct。

如果这道题没有k，那怎么去做呢，就是将起点s的状态先扔进queue中去bfs，搜到终点e就是得到了答案，并且开一个数组vis[x, y]记录点(x, y)是否被走过，走过的话就不用走了（因为再走的话也是绕远的了，只有第一次进队列是时间最短的方案）

但是这道题多了一个k，那么这时候就可能导致，在时间为t时走到(x, y)进而走到终点的时间可能会>时间为t+1时走到(x, y)进而走到终点的时间，也就是说，过程中某个点的最优解并不一定是最后的全局最优解了。那么面对这种情况，我们开一个数组vis[x, y, t]记录状态：到点(x, y)，时间对k取模为t 是否进过队列。因为每隔k秒怪兽会消失，所以比如到点(x, y)时，时间%k=1这一状态，不管t=k+1还是2k+1，对后续的影响（怪兽消失）的一模一样的，所以这样记录状态是考虑到了所有可能对ans产生贡献的状态。

那么按上述改进方法记录状态并且bfs一遍就能得到答案了。



第23题
这道题一开始我没什么想法，只想到了爆搜，但是算算复杂度肯定是不行的。

但是后来也没想到什么好的做法，所以就想了想剪枝（剪去一些不符合要求的不用继续搜索下去）。具体搜索就是枚举每一个小区域逆时针旋转多少次。

然后剪枝部分就是判断一下当前小区域转到的这个方向使得其所在的四列、四行中已经搜索完的部分是不是每个数都只出现了一次，如果不是的话就不用继续搜索下去了，因为已经不满足条件了。

然后这个的复杂度我也不会算，感觉比较玄学，不过实际速度是挺快的0.045秒就过了。



第24题

这道题还是一道图论题，对于事件A能够推出事件B，我们从A向B连一条有向边。注意题目要求的是最少能够用前几条线索形成逻辑闭环完成推理。

所以我们可以考虑二分答案，剩下的任务就是chk函数怎么写。

其实问题就变成了由前mid条边组成的有向图是否有环的问题。在这里我是利用拓扑排序判断的。

拓扑序：对一个有向无环图(DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。

那么如何求拓扑序呢？我们用一个queue维护当前入度为0的点，每次取出队首的点u，将与u相连的边都删掉并将边所连到的点v的入度--，若为0加入queue，直到队列为空。

如果有环，就会出现一种情况：就是有很多点的入度都还不为0但是队列空了。所以我们可以利用这一点判环。



第25题

写这篇题解前学到了O(n)的做法，就是求前缀的平均数的最大值，可以意会但不会证明...

我的做法就是，看到这种求什么最大值最小的问题，一般都先考虑一下二分答案。

那么我们就二分一下答案，如果当前二分的mid能够被满足，那么我们就看看能不能把答案进一步缩小；否则放大（这大概就是二分答案的思想吧）。

然后chk函数的过程就是我们从右往左扫，如果有>mid的部分，我们就把它往左推，如果最后还有剩余，那显然当前的mid不能被满足且让l=mid+1；反之则更新答案并让r=mid-1;



第26题


这道题我们可以根据数据范围确定大概是O(n)的做法。

因为不需要什么优化，所以很容易想到我们用f[i, j]表示前i个数，选了j队，其中第i个数必选（为什么能想到这个，我觉得是因为就是你要的3队人都是连续的，如果没有这个限制的话，我们转移的时候不好确定上一队人在哪里结束，进而不好确定接下来该怎么选）。

接下来就是考虑转移的事，对于f[i, j]，也就是前i人选j队，第i个必选，它可以从：

1. i-1个人选j队转移过来

2. 从i-1人选j-1队；i-2人选j-1队... j-1人选j-1队转移过来

情况1是延续当前第j队；情况2则是我们找到已经选好的j-1个队的最大值，然后当前新开一个队，里面当前只有第i个数

可见我们转移的时候应该把j（取值1~3）放在外层循环（也就是说先算完1个队的情况再算2各队的情况这样），i放在内层循环，并从1到n循环。

根据上面我们写出状态转移方程：

f[i, j] = max{f[i - 1, j], f[k, j - 1]} + a[i]，其中 j-1 <= k <= i-1

然后ans就是max{f[i, 3]}，其中 3 <= i <= n



第27题

这道题根据数据范围我们也能判断出dp的时间复杂度大概是O(nV)的。至于pi的这个限制我好像还真没用上...

我们设f[i, j]表示前i个物品，选取一些物品使得总体积%V == j的方案数。

那么转移的时候就是

f[i, (j + p[i]) % V] += f[i - 1, j]

f[i, j] += f[i - 1, j]

其中，第一个式子表示的是当前第i个物品选，第二个式子是当前物品不选，直接把i-1的f值copy到i中。

其实感觉这题更是一个递推，也没有什么取max或min的过程。

ans就是f[n, 0]-1，减去的1来自f[0][0]，即一件物品都不取的情况



第28题

这道题其实我感觉箭头这东西好像没什么用？可能就是方便输入用的吧qwq

根据数据范围应该是O(n^2)的

像这种题一般都是我们开二维数组，这道题我们设f[i, j]表示从底到上前i个，其中第i个的起点为j的方案数。

设输入的是a[0],...,a[n]共n+1个数。

那么对于状态转移中的两重循环，外层循环肯定就是枚举i=1~n；由于第二维是记录的起点，所以我们内层循环枚举第i-1个块的起点，那么第i-1个块箭头位置是a[i-1]，也就是说i-1这个块在min(j, a[i-1]) - max(j, a[i-1])之间，将这两个端点设为l和r；判断a[i]即第i块箭头的位置和l、r的位置关系，将f[i - 1, j]累加到f[i, l / r]中（保证有一段对齐）。注意取模操作。

ans = f[n, i]， 1 <= i <= n+1



第29题

这道题是一道树上dp，其实也不太算，就是dfs一遍。

首先n个点，n-1条边的图，应该就是一棵树。

我们考虑初级版的题目，也就是不加新边的那种，这时候我们考虑每条边对ans的贡献，设一条边连着u和v，其中u是v的父亲节点，那么那些路径会走过这条边呢？设v的子树大小（即节点个数）为sz[v]，利用简单的乘法原理，可以知道路过这条边的路径数为sz[v] * (n - sz[v])。设此时得到的路径长度总和为ans‘

然后考虑升级版的，也就是这道题的题面。不难想到如果一条上述题面的路径长度是偶数，那么在这道题里就应该/2；如果是奇数，就应该(+1)/2（即上取整）。

现在就是要判断有多少条原本最短路径长度（即初级班题面的路径）为奇数的路径数了。设dep[i]为i的深度（根dep[1]=0）。那么根据dist(u, v) = dep[u] + dep[v] - 2 * dep[lca(u, v)]，其中lca(u, v)为u和v的最近公共祖先（离两个点最近的公共祖先），若dist(u, v)为奇数，那么意味着dep[u]和dep[v]一奇一偶。

所以我们可以dfs一遍树然后求出每个点的深度dep，设dep为奇数的点的个数为cnt_o；dep为偶数的点的个数为cnt_e。根据乘法原理可得原本的路径长度为奇数的个数为cnt_o*cnt_e。

所以ans就=(ans' + cnt_o*cnt_e) / 2;

注意一下开long long记录。



第30题

按正常的思路（同27的套路），w[ ]数组存储各瓜的重量，用dp[i][j]表示给出第i个瓜（但是不一定拿这个瓜）、重量为j时的金粒子数，那么dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+g[i]),这个递推式中，前一项表示第i个瓜不拿，后一项表示第i个瓜要拿。

增加了一个要求就在每个对j的循环里在套一个对k的循环，其他都不需要做重大修改。

讲背包的帖子蛮多，就简单提一下，我主要想写一下我对压缩数组的理解。

首先，每一行的数据都只与前一行有关，前一行的前一行或前几行都不会影响，这奠定了压缩数组的基础。

其次，也是因为每一行数据与前一行数据有关，所以在新一行数据更新完成之前，更新所需的数据不能被改变。

同时，每次更新的数据都只涉及列数不大于它的。

综合这三点，可以直接把i这个维度拿掉，然后每次倒序更新数组，就可以实现数组压缩，并且不属于时间换空间的做法。